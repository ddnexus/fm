#!/usr/bin/env sh

# Copyright (c) 2021 Domizio Demichelis
# Released under GNU3 license
# https://www.gnu.org/licenses/gpl-3.0.en.html


set -e

if [ $(id -u) = 0 ]; then
   echo 'This script is not supposed to be run as root!'
   exit
fi

root="$(cd -P -- "$(dirname -- "$0")" && printf '%s\n' "$(pwd -P)")"

fm_name='try-fm'
context=${TRY_FM_CONTEXT:-https://github.com/ddnexus/fm.git#master:try-fm/docker}

fm_image="$fm_name"
fm_vol='fm_user_home'
zsh_image='zshusers/zsh:5.8'

script_file="$root/$fm_name"
vol_file="$root/.${fm_name}_vol"
zsh_file="$root/.${fm_name}_zsh"

check_docker() {
	if ! docker info 1>/dev/null 2>&1; then
		echo "Docker is not running!"
		exit
	fi
}

case "$1" in
	start|s)
		check_docker

		if docker image inspect $zsh_image 1>/dev/null 2>&1; then
			touch "$zsh_file"
		fi

		if ! docker image inspect $fm_image 1>/dev/null 2>&1; then
			cat <<-BUILDING

				================================= BUILD IMAGE =================================
				NOTICE: All the required packages will be installed and relegated to the
				'$fm_name' docker image. The installation will not change your system in any way.
				You can cleanup the docker stuff at any time by running '~/$fm_name purge'
				===============================================================================
			BUILDING
			sleep 1

			while true; do
				printf '%s ' 'Create your user password for the docker image:'
				stty -echo; read password; stty echo; echo
				if [ -z $password ]; then
					echo 'The password cannot be blank'
					continue
				fi
				printf '%s ' 'Confirm your password:'
				stty -echo; read confirm; stty echo; echo
				if [ "$password" != "$confirm" ]; then
					echo 'The passwords did not match'
					continue
				fi
				echo 'Please, remember your password or you will have to re-build this image.'
				break
			done

			DOCKER_BUILDKIT=0 docker build \
					--tag $fm_image \
					--build-arg password="$password" \
					--build-arg user="$(id -un)" \
					--build-arg uid=$(id -u) \
					--build-arg gid=$(id -g) \
					--build-arg term="$TERM" \
					$context

			echo "The '$fm_name' docker image has been built!"
		fi

		if ! [ -e "$vol_file" ]; then
			unameOut="$(uname -s)"
			case "${unameOut}" in
				Linux*)   machine=linux ;;
				Darwin*)  machine=mac ;;
				CYGWIN*)  machine=cygwin ;;
				MINGW*)   machine=minGw ;;
				*)        machine="UNKNOWN:${unameOut}" ;;
			esac
			if [ "$machine" = "mac" ]; then
				cat <<-CAVEATS

				=============================== MACOS CAVEATS =================================
				The FIND view (alt-f) may be very slow in docker bind mounted paths: that
				will work super fast when FM will be installed and run directly
				===============================================================================
				CAVEATS
				sleep 2
			fi
			cat <<-CAVEATS

				============================= TERMINAL CAVEATS ================================
				FM uses the alt/option key as meta character in many shortcuts. If the alt key
				does not work as a shortcut modifier, then read the solution in the Q&A:
				https://github.com/ddnexus/fm/tree/master/try-fm#Q&A
				===============================================================================
			CAVEATS
			sleep 2
		fi

		case "$2" in
			--root-mount|-r|'')
				cat <<-WARNING

					%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% !!! WARNING !!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
					FM and this demo is safe and requires you to confirm deletions and enter the
					sudo password for protected items, however:
					* Your own filesystem will be writable and mounted at /$(hostname)
					* Your original home dir will be writable and available at /$(hostname)$HOME
					Don't do anything stupid with your own files.
					If you want to try deletions, create dummy files first ;)
					%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				WARNING
				;;
			--home-mount|-h)
				cat <<-WARNING

					%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% !!! WARNING !!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
					FM and this demo is safe and requires you to confirm deletions and enter the
					sudo password for protected items, however:
					* Your original home dir will be writable and available at /$(hostname)-$USER
					Don't do anything stupid with your own files.
					If you want to try deletions, create dummy files first ;)
					%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				WARNING
				;;
			--no-mount|-n) : ;;
			*)
				echo "The option '$2' is not supported"
				exit
				;;
		esac

		cat <<-WELCOME

			============================== IMPORTANT INFO =================================
			Starting a zsh shell session in the '$fm_name' docker container...
			* Session Login: $USER   Password: <your-password>
			* The HOME in the docker container will be /home/$USER
			* Edit the /home/$USER/.zshrc to experiment with it
			* Your changes in /home/$USER will survive rebooting
			* You can reset /home/$USER by running '~/$fm_name reset' after exiting
			  the docker session
			* You can reclaim your disk space by removing all the docker objects related
			  to '$fm_name' by running '~/$fm_name purge' after exiting the docker session

			=============================== BASIC USAGE ===================================
			* Run the fm command to start, then press 'ctrl-space' to get the menu with
			  the inline documentation.
			* Press 'alt-f' twice (rapidly) in the prompt to get the widget
			* Quit FM or the widget with 'ctrl-q', 'ctrl-c' or 'esc'
			* Exit from the docker session with the usual 'exit'
		WELCOME

		if ! [ -e "$vol_file" ]; then
			echo
			read -p "Please, confirm that you have read and understood the above messages (y/n)> " input
			if [ "$input" = y ] || [ "$input" = Y ]; then
				echo "Running the '$fm_name' docker container..."
			else
				echo "OK, see you next time"
				exit
			fi
			touch "$vol_file"
		fi

		case "$2" in
			--root-mount|-r|'')
				docker run \
						--name $fm_name \
						--env DISPLAY \
						--volume /tmp/.X11-unix:/tmp/.X11-unix:rw \
						--volume $fm_vol:/home/$USER \
						--volume /:/$(hostname) \
						--workdir /$(hostname)$HOME \
						--interactive \
						--tty \
						--rm \
						$fm_image
				;;
			--home-mount|-h)
				docker run \
						--name $fm_name \
						--env DISPLAY \
						--volume /tmp/.X11-unix:/tmp/.X11-unix:rw \
						--volume $fm_vol:/home/$USER \
						--volume $HOME:/$(hostname)-$USER \
						--workdir /$(hostname)-$USER \
						--interactive \
						--tty \
						--rm \
						$fm_image
				;;
			--no-mount|-n)
				docker run \
						--name $fm_name \
						--env DISPLAY \
						--volume /tmp/.X11-unix:/tmp/.X11-unix:rw \
						--volume $fm_vol:/home/$USER \
						--interactive \
						--tty \
						--rm \
						$fm_image
				;;
			*)
				echo "The option '$2' is not supported."
				exit
				;;
		esac
		;;

	reset|r)
		check_docker
		read -p "Reset HOME and plugins? (y/n)> " input
		if [ "$input" = y ] || [ "$input" = Y ]; then
			echo "Removing the '$fm_vol' docker volume..."
			docker volume rm $fm_vol
			rm -f "$vol_file"
			echo "Reset done. You can start the '$fm_name'"
		fi
		;;

	purge|p)
		check_docker
		read -p "Purge everything related to '$fm_name' from your system? (y/n)> " input
		if [ "$input" = y ] || [ "$input" = Y ]; then
			if [ -e "$zsh_file" ]; then
				docker rmi $fm_image
			else
				docker rmi $fm_image $zsh_image
			fi
			docker volume rm $fm_vol
			if [ "$(printf '%-.1s\n' "$context")" = '/' ]; then
				rm -fv "$vol_file"
			else
				rm -fv "$script_file" "$vol_file" "$zsh_file"
			fi
			echo "'$fm_name' has been completely purged from your system!"
		fi
		;;

	usage|u|'')
		cat <<-USAGE

			==================================== USAGE ====================================
			~/$fm_name start|s    Setup and start the docker session...
			 [--root-mount|-r]  ...with default mount of / at /$(hostname)
			  --home-mount|-m   ...with mount of $HOME at /$(hostname)-$USER
			    --no-mount|-n   ...without any mount

			~/$fm_name reset|r    Reset so the next start will restore HOME and plugins
			~/$fm_name purge|p    Purge everything related to '$fm_name' from your system
			~/$fm_name usage|u    Show this screen
			===============================================================================
		USAGE
		;;

	*)
		echo "The subcommand '$1' is not supported!"
		;;
esac
